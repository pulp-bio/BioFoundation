# Copyright (c) 2026 Thorir Mar Ingolfsson, ETH Zurich
# SPDX-License-Identifier: Apache-2.0

"""Generate a support matrix markdown from extractor/runtime metadata."""

from __future__ import annotations

import argparse
import inspect
import re
import sys
from pathlib import Path
from typing import Dict, List, Sequence

REPO_ROOT = Path(__file__).resolve().parent.parent
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from tools.ares_support_registry import (
    get_optype_mapping,
    get_supported_layer_types,
)


def collect_extractor_types() -> Sequence[str]:
    """Return extractor-supported layer type names."""
    return get_supported_layer_types()


def collect_custom_layer_classes() -> List[str]:
    """Collect custom layer class names from test custom layer module."""
    class_names: List[str] = []
    try:
        from tests.test_networks import brevitas_custom_layers as bcl  # type: ignore
    except ImportError:
        from test_networks import brevitas_custom_layers as bcl  # type: ignore

    for name, obj in vars(bcl).items():
        if inspect.isclass(obj) and obj.__module__ == bcl.__name__ and name.startswith("Quant"):
            class_names.append(name)
    return sorted(class_names)


def collect_runtime_optypes() -> List[str]:
    """Parse OpType enum entries from runtime header."""
    header = REPO_ROOT / "codegen/runtime/inc/layer_descriptors.h"
    text = header.read_text()
    optypes = sorted(set(re.findall(r"\bOP_[A-Z0-9_]+\b", text)))
    return [name for name in optypes if name != "OP_UNKNOWN"]


def _default_class_hint(layer_type: str) -> str:
    mapping = {
        "QuantIdentity": "brevitas.nn.QuantIdentity",
        "QuantConv2d": "brevitas.nn.QuantConv2d",
        "QuantReLU": "brevitas.nn.QuantReLU",
        "QuantLinear": "brevitas.nn.QuantLinear",
        "MaxPool2d": "torch.nn.MaxPool2d",
        "AvgPool2d": "torch.nn.AvgPool2d",
        "GlobalAvgPool": "torch.nn.AdaptiveAvgPool2d",
        "AdaptiveAvgPool1d": "torch.nn.AdaptiveAvgPool1d",
        "ZeroPad2d": "torch.nn.ZeroPad2d",
        "LayerNorm": "torch.nn.LayerNorm",
        "RMSNorm": "torch.nn.RMSNorm / class-name RMSNorm",
        "GroupNorm": "torch.nn.GroupNorm",
        "Embedding": "torch.nn.Embedding",
        "GELU": "torch.nn.GELU",
        "Flatten": "torch.nn.Flatten",
        "Squeeze": "class-name Squeeze",
        "Permute": "class-name Permute",
        "Reshape": "class-name Reshape",
        "RFFT": "class-name RFFT / RFFTFeatures / RFFTFeature",
        "Add": "QuantAdd",
        "Concatenate": "QuantConcatenate",
        "Mean": "QuantMean",
        "MultiheadSelfAttention": "QuantSelfAttention / QuantMultiHeadAttention / QuantRoPESelfAttention / QuantMHSA",
        "CrossAttention": "QuantCrossAttention",
        "AlternatingAttention": "QuantAlternatingAttention",
        "Conv1dDepthwise": "QuantConv1dDepthwise",
        "SiLU": "QuantSiLU",
        "SSM": "QuantSSM",
        "MambaWrapper": "QuantMambaWrapper",
        "PatchEmbed": "QuantPatchEmbed",
        "MambaBlock": "QuantMambaBlock",
    }
    return mapping.get(layer_type, "N/A")


def render_supported_operations_md(
    extractor_types: Sequence[str],
    custom_classes: Sequence[str],
    runtime_optypes: Sequence[str],
) -> str:
    """Render markdown summary."""
    optype_map = get_optype_mapping()
    lines: List[str] = []
    lines.append("# Supported Operations (Generated)")
    lines.append("")
    lines.append("This file is generated by `tools/generate_supported_operations_doc.py`.")
    lines.append("")
    lines.append("## Extractor Layer Types")
    lines.append("")
    lines.append("| Extracted layer type | Python class detector | Runtime mapping |")
    lines.append("|---|---|---|")
    for layer_type in extractor_types:
        lines.append(
            f"| `{layer_type}` | `{_default_class_hint(layer_type)}` | `{optype_map.get(layer_type, 'N/A')}` |"
        )

    lines.append("")
    lines.append("## Custom Layer Classes")
    lines.append("")
    for name in custom_classes:
        lines.append(f"- `{name}`")

    lines.append("")
    lines.append("## Runtime OpType Enum Entries")
    lines.append("")
    for name in runtime_optypes:
        lines.append(f"- `{name}`")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate supported operations markdown.")
    parser.add_argument(
        "--output",
        default=str(REPO_ROOT / "docs/SUPPORTED_OPERATIONS.generated.md"),
        help="Output markdown path.",
    )
    args = parser.parse_args()

    content = render_supported_operations_md(
        extractor_types=collect_extractor_types(),
        custom_classes=collect_custom_layer_classes(),
        runtime_optypes=collect_runtime_optypes(),
    )
    out_path = Path(args.output)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(content)
    print(f"Wrote {out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
